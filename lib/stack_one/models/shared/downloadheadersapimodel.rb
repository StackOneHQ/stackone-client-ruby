# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module StackOne
  module Models
    module Shared
    

      class DownloadHeadersApiModel
        extend T::Sig
        include Crystalline::MetadataFields

        # Value of the Content-Disposition header
        field :content_disposition, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::StackOne::Utils.field_name('content-disposition') } }
        # Encoding of the content
        field :content_encoding, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::StackOne::Utils.field_name('content-encoding') } }
        # Size of the content in bytes
        field :content_length, Crystalline::Nilable.new(::Float), { 'format_json': { 'letter_case': ::StackOne::Utils.field_name('content-length') } }
        # Range of the content being sent
        field :content_range, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::StackOne::Utils.field_name('content-range') } }
        # MIME type of the file
        field :content_type, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::StackOne::Utils.field_name('content-type') } }
        # Transfer encoding type
        field :transfer_encoding, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::StackOne::Utils.field_name('transfer-encoding') } }

        sig { params(content_disposition: T.nilable(::String), content_encoding: T.nilable(::String), content_length: T.nilable(::Float), content_range: T.nilable(::String), content_type: T.nilable(::String), transfer_encoding: T.nilable(::String)).void }
        def initialize(content_disposition: nil, content_encoding: nil, content_length: nil, content_range: nil, content_type: nil, transfer_encoding: nil)
          @content_disposition = content_disposition
          @content_encoding = content_encoding
          @content_length = content_length
          @content_range = content_range
          @content_type = content_type
          @transfer_encoding = transfer_encoding
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @content_disposition == other.content_disposition
          return false unless @content_encoding == other.content_encoding
          return false unless @content_length == other.content_length
          return false unless @content_range == other.content_range
          return false unless @content_type == other.content_type
          return false unless @transfer_encoding == other.transfer_encoding
          true
        end
      end
    end
  end
end
